Initially, my strategy was to generate a white list (indicating all expressions
with guaranteed termination) and a black list (indicating all expression with
guaranteed nontermination) and remove rules that had symbols from the black
list or were not present in the white list. After implementing both lists, I
realized that the desired functionality could be obtained with only the white
list. My final solution is as follows:

1. Generate initial white list. (A list containing nonterminals that have a
derivation where all elements on the right hand side of the rule are terminal.)
2. Iteratively generate the final white list. (A list containing nonterminals
that can reach a terminal state after an arbitrary number of iterations.)
3. Remove any rule from the grammar that contains (either on the left or right
hand side) a symbol that is not present in the white list.
